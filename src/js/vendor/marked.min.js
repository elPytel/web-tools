// Minimal local fallback for marked.parse
// This is a tiny parser providing basic support for headings, code blocks, and paragraphs.
(function(global){
  function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  function parse(md){
    // handle code fences ```
    let out = '';
    const lines = md.split(/\r?\n/);
    let inCode = false; let codeLang = '';
    for (let i=0;i<lines.length;i++){
      const l = lines[i];
      if (l.startsWith('```')){
        if (!inCode){ inCode = true; codeLang = l.slice(3).trim(); out += '<pre><code>'; }
        else { inCode = false; out += '</code></pre>\n'; }
        continue;
      }
      if (inCode){ out += escapeHtml(l) + '\n'; continue; }
      if (/^#{1,6}\s+/.test(l)){
        const m = l.match(/^(#{1,6})\s+(.*)$/);
        const level = m[1].length;
        out += `<h${level}>${escapeHtml(m[2])}</h${level}>\n`;
        continue;
      }
      if (/^>\s?\[!\w+\]/.test(l)){
        // simple blockquote/admonition passthrough as paragraph
        out += '<blockquote>' + escapeHtml(l.replace(/^>\s?/, '')) + '</blockquote>\n';
        continue;
      }
      if (l.trim()==='') { out += '\n'; continue; }
      // inline code
      const inline = l.replace(/`([^`]+)`/g, function(_,c){ return '<code>'+escapeHtml(c)+'</code>'; });
      out += '<p>' + inline + '</p>\n';
    }
    return out;
  }

  global.marked = { parse };
})(window);
