<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8"/>
  <title>üîì Rainbow / Password cracking playground</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="../css/style.css">
  <style>
    .grid2 { display:grid; gap:12px; grid-template-columns: 1fr 1fr; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    /* nov√Ω styl: vertik√°ln√≠ konfigurace */
    .config-col { display:flex; flex-direction:column; gap:10px; }
    .config-col label { display:block; }
    textarea { width:100%; min-height:120px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    table { width:100%; border-collapse: collapse; }
    table th, table td { padding:6px 8px; border-bottom:1px solid var(--border); font-size:14px; }
    .console { background: var(--panel-2); padding:8px; border-radius:8px; max-height:220px; overflow:auto; font-family: ui-monospace, monospace; font-size:13px; }
    .ok { background: linear-gradient(90deg, rgba(16,185,129,0.08), rgba(16,185,129,0.02)); }
    .danger { background: linear-gradient(90deg, rgba(239,68,68,0.06), rgba(239,68,68,0.02)); }
    progress { width:100%; height:14px; }
    .flex-between { display:flex; justify-content:space-between; align-items:center; gap:12px; }
  </style>
  <!-- SparkMD5 UMD build (exposes global SparkMD5.hash) -->
  <script src="https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js"></script>
</head>
<body>
  <div class="app">
    <script type="module" src="../js/site-header.js"></script>
    <site-header title="üîì Rainbow / Password cracking playground"></site-header>

    <!-- DB leak configuration card -->
    <section class="card">
      <h2>Simulovan√Ω √∫nik DB ‚Äì konfigurace</h2>
      <div id="configPanel" class="config-col" style="max-width:560px">
        <label>Poƒçet z√°znam≈Ø:
          <input id="numRows" type="number" min="1" max="500" value="20" class="small-input">
        </label>
        <label>Algoritmus hashe:
          <select id="algo">
            <option value="MD5" selected>MD5 (ilustrativnƒõ)</option>
            <option value="SHA-1">SHA-1</option>
            <option value="SHA-256">SHA-256</option>
          </select>
        </label>
        <label>Salt:
          <select id="saltMode">
            <option value="none" selected>≈Ω√°dn√Ω</option>
            <option value="per-user">Per-user random salt</option>
            <option value="regdate">Odvozen√° z datumu registrace</option>
          </select>
        </label>
        <div class="row" id="saltOptions" style="display:none">
          <label>Salt um√≠stƒõn√≠:
            <select id="saltPos"><option value="suffix">Suffix</option><option value="prefix">Prefix</option></select>
          </label>
        </div>

        <div style="margin-top:12px" class="small muted">
          Pozn√°mka: Rainbow tables vƒõt≈°inou nefunguj√≠ p≈ôi pou≈æit√≠ salt≈Ø. Tato simulace ilustruje oba p≈ô√≠stupy.
        </div>

        <div style="margin-top:12px">
          <button id="btnGen" class="btn primary">Generovat DB</button>
          <button id="btnClear" class="btn">Vyƒçistit</button>
        </div>
        <!-- Leak wordlist controls: independent source for passwords used in the leaked DB -->
        <div style="margin-top:12px; border-top:1px solid var(--border); padding-top:10px;">
          <label style="font-weight:600; display:block; margin-bottom:6px">Zdroj slovn√≠ku pro unik (hesla v unikl√© DB):</label>
          <label>Zdroj slovn√≠ku: 
            <select id="leakWordlistChoice"></select>
          </label>
          <div id="leakUploadBox" style="display:none; margin-top:6px;">
            <input id="leakWordlistFile" type="file" accept=".txt" />
            <div class="small muted">Soubor: jeden kandid√°t na ≈ô√°dek.</div>
          </div>
          <label style="margin-top:6px">N√°hled slovn√≠ku (unik):</label>
          <textarea id="leakWordlistPreview" readonly class="small-input" style="width:100%; min-height:80px; margin-top:6px;"></textarea>
        </div>
      </div>
    </section>

    <!-- Attack / cracking configuration card -->
    <section class="card">
      <h2>√ötoƒçn√≠k - l√°m√°n√≠ hesel</h2>
      <div style="display:flex; flex-direction:column; gap:10px; max-width:680px;">
        <label>Zdroj slovn√≠ku:
          <select id="wordlistChoice"></select>
        </label>
        <div id="uploadBox" style="display:none">
          <input id="wordlistFile" type="file" accept=".txt" />
          <div class="small muted">Soubor: jeden kandid√°t na ≈ô√°dek.</div>
        </div>

        <label>N√°hled slovn√≠ku (l√°m√°n√≠):
          <textarea id="wordlistPreview" readonly class="small-input" style="width:100%; min-height:140px; margin-top:6px;"></textarea>
        </label>

        <label>Poƒçet zkou≈°en√Ωch kandid√°t≈Ø (z wordlistu) / limit:
          <input id="limit" type="number" min="1" max="1000000" value="5000" class="small-input">
        </label>

        <label>√ötoƒçn√Ω re≈æim:
          <select id="attackMode">
            <option value="bruteforce" selected>Brute-force</option>
            <option value="wordlist" selected>Wordlist</option>
            <option value="wordlist_salted" selected>Wordlist + salt</option>
            <option value="rainbow">Rainbow table (precompute hash‚Üípwd)</option>
          </select>
        </label>

        <div style="margin-top:8px" class="row">
          <button id="btnStart" class="btn primary">‚ñ∂ Spustit √∫tok</button>
          <button id="btnStop" class="btn">‚ñ† Zastavit</button>
        </div>

        <div style="margin-top:8px">
          <div class="small muted">Zobrazen√Ω progres reflektuje poƒçet testovan√Ωch kandid√°t≈Ø.</div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="flex-between">
        <h3>Unikl√© z√°znamy (vybran√©)</h3>
        <div class="small muted">Kdy≈æ je heslo nalezeno, ≈ô√°dek se zv√Ωrazn√≠ zelenƒõ.</div>
      </div>

      <div style="margin-top:8px; overflow:auto">
        <table id="dbTable" role="table">
          <thead>
            <tr>
              <th>#</th><th>Email</th><th>Hash</th><th>Reg date</th><th>Cracked?</th><th>Plain</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div style="margin-top:10px">
        <progress id="progress" value="0" max="1"></progress>
      </div>
      <div style="margin-top:10px" class="console" id="console"></div>
    </section>
  <script type="module" src="../js/site-doc.js"></script>
    <site-doc src="rainbow_tables_explain.md" title="üìò Vysvƒõtlen√≠" toggle></site-doc>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.10.0/styles/github-dark.min.css">
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.10.0/lib/common.min.js"></script>

<script type="module">

  const $ = (s, r=document) => r.querySelector(s);
  const $$ = (s, r=document) => [...r.querySelectorAll(s)];

  import {loadWordlistFromPath, digestText, makeSalt, randHex, randEmail, randDate, WORDLISTS } from '../js/cybersec.js';

  // leak-specific wordlist state (used for generating leaked DB pool)
  let leakWordlist = [];

  const numRowsEl = $('#numRows');
  const algoEl = $('#algo');
  const saltModeEl = $('#saltMode');
  const saltOptionsEl = $('#saltOptions');
  const saltLenEl = $('#saltLen');
  const saltPosEl = $('#saltPos');
  const configPanel = $('#configPanel');

  const wordlistChoiceEl = $('#wordlistChoice');
  const uploadBox = $('#uploadBox');
  const fileEl = $('#wordlistFile');
  const previewEl = $('#wordlistPreview');
  const leakWordlistChoiceEl = $('#leakWordlistChoice');
  const leakUploadBox = $('#leakUploadBox');
  const leakFileEl = $('#leakWordlistFile');
  const leakPreviewEl = $('#leakWordlistPreview');
  const limitEl = $('#limit');
  const attackModeEl = $('#attackMode');

  const btnGen = $('#btnGen');
  const btnClear = $('#btnClear');
  const btnStart = $('#btnStart');
  const btnStop  = $('#btnStop');

  const dbTableBody = $('#dbTable tbody');
  const consoleEl = $('#console');
  const progressEl = $('#progress');

  // State
  let db = []; // {email, hash, salt, regdate, cracked:false, plain:null}
  let running = false;
  let stopRequested = false;
  let wordlist = []; // candidates array

  // ========== helpers ==========
  function log(...args){
    const line = `[${new Date().toLocaleTimeString()}] ${args.join(' ')}`;
    const el = document.createElement('div');
    el.textContent = line;
    consoleEl.appendChild(el);
    consoleEl.scrollTop = consoleEl.scrollHeight;
  }

  function clearLog(){ consoleEl.innerHTML = ''; }

  // ========== DB generation ==========
  async function generateDB(){
    // reset
    db = [];
    dbTableBody.innerHTML = '';
    clearLog();
    stopRequested = false;
    running = false;

    const n = Math.max(1, Math.min(500, parseInt(numRowsEl.value)||20));
    const algo = algoEl.value;
    const saltMode = saltModeEl.value;
    const saltLen = 8;
    log(`Generuji ${n} z√°znam≈Ø (algo=${algo}, salt=${saltMode}${saltMode!=='none'?` len=${saltLen} pos=${saltPosEl.value}`:''})`);
    
    let numberOfRandomPasswords = 0;
    for (let i=0;i<n;i++){
      const email = randEmail();
      // generate regdate before salt if salt may be derived from it
      const regdate = randDate();
      // pick a password from pool mostly (to allow cracking)
      let pwd = ""
      if (Math.random() < 0.8) {
        pwd = leakWordlist[Math.floor(Math.random()*leakWordlist.length)]
      } else {
        // random pwd (not in pool)
        pwd = Math.random().toString(36).slice(2,10);
        numberOfRandomPasswords++; 
      }
      
      let salt = '';
      if (saltMode === 'per-user'){
        salt = makeSalt(saltLen, null, 'random');
      } else if (saltMode === 'regdate'){
        // deterministic salt based on registration date
        salt = makeSalt(saltLen, regdate, 'regdate');
      }
      const salted = ((saltMode === 'per-user' || saltMode === 'regdate') && saltPosEl.value === 'prefix') ? (salt + pwd) : (pwd + salt);
      const hash = await digestText(algo, salted);
      db.push({ id:i+1, email, hash, salt: (saltMode==='per-user' || saltMode==='regdate')?salt:'', regdate, cracked:false, plain: null, orig: pwd });
    }

    renderDB();
    log('Hotovo ‚Äì DB vygenerov√°na. Nƒõkter√© hesla jsou z bƒõ≈æn√Ωch seznam≈Ø (provediteln√©).');
    log(`${numberOfRandomPasswords}/${n} hesel je n√°hodn√Ωch.`);
  }

  function renderDB(){
    dbTableBody.innerHTML = '';
    for (const row of db){
      const tr = document.createElement('tr');
      tr.dataset.id = row.id;
      tr.className = row.cracked ? 'ok' : '';
      tr.innerHTML = `
        <td>${row.id}</td>
        <td>${row.email}</td>
        <td style="font-family: ui-monospace">${row.hash}</td>
        <td>${row.regdate}</td>
        <td>${row.cracked ? '‚úÖ' : ''}</td>
        <td style="font-family: ui-monospace">${row.plain || ''}</td>
      `;
      dbTableBody.appendChild(tr);
    }
  }

  // Populate wordlist select(s) from WORDLISTS mapping.
  // If el parameter is omitted, populate attacker select; otherwise populate provided element.
  function populateWordlistOptions(el){
    const target = el || wordlistChoiceEl;
    target.innerHTML = '';
    for (const key of Object.keys(WORDLISTS)){
      const opt = document.createElement('option');
      opt.value = key;
      opt.textContent = WORDLISTS[key].label;
      if (key === 'builtin') opt.selected = true;
      target.appendChild(opt);
    }
    const optUpload = document.createElement('option');
    optUpload.value = 'upload';
    optUpload.textContent = 'Upload .txt';
    target.appendChild(optUpload);
  }

  // helper to populate both attacker and leak selects
  function populateAllWordlistOptions(){
    populateWordlistOptions(wordlistChoiceEl);
    populateWordlistOptions(leakWordlistChoiceEl);
  }

  async function loadWordlist(){
    const choice = wordlistChoiceEl.value;
    wordlist = [];
    if (choice === 'upload'){
      const f = fileEl.files[0];
      if (!f) {
        alert('Nahraj .txt soubor se slovn√≠kem (jedno heslo na ≈ô√°dek).');
        return;
      }
      const txt = await f.text();
      wordlist = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    } else {
      const entry = WORDLISTS[choice];
      if (!entry) { wordlist = []; return; }
      else {
        try {
          const res = await fetch(entry.path, { cache: 'no-store' });
          if (!res.ok) throw new Error('wordlist not found');
          const txt = await res.text();
          wordlist = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
        } catch (err) {
          alert('Chyba: nepoda≈ôilo se naƒç√≠st ' + (entry.path || choice) + ': ' + (err.message||err));
          wordlist = [];
        }
      }
    }
    log(`Wordlist naƒçten (${wordlist.length} polo≈æek)`);
    if (previewEl) previewEl.value = wordlist.join('\n');
    return wordlist;
  }

  // load leak-specific wordlist (used for generov√°n√≠ unikl√© DB)
  async function loadLeakWordlist(){
    const choice = leakWordlistChoiceEl.value;
    leakWordlist = [];
    if (choice === 'upload'){
      const f = leakFileEl.files[0];
      leakPreviewEl.value = f ? await f.text() : '';
      if (!f) return leakWordlist;
      leakWordlist = (await f.text()).split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    } else {
      const entry = WORDLISTS[choice];
      if (!entry) { leakWordlist = []; }
      else {
        try {
          const res = await fetch(entry.path, { cache: 'no-store' });
          if (!res.ok) throw new Error('wordlist not found');
          const txt = await res.text();
          leakWordlist = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
          leakPreviewEl.value = leakWordlist.join('\n');
        } catch (err) {
          alert('Chyba: nepoda≈ôilo se naƒç√≠st ' + (entry.path || choice) + ': ' + (err.message||err));
          leakWordlist = [];
          leakPreviewEl.value = '';
        }
      }
    }
    log(`Leak wordlist naƒçten (${leakWordlist.length} polo≈æek)`);
    return leakWordlist;
  }

  // ========== Leak wordlist loader/preview ==========


  // Unified preview updater for both attacker and leak previews
  // selectEl: the <select> element (wordlistChoiceEl or leakWordlistChoiceEl)
  // previewEl: the textarea element to fill
  // fileInputEl: optional file input to read when "upload" selected
  async function updatePreviewFor(selectEl, previewEl, fileInputEl = null) {
    if (!previewEl || !selectEl) return;
    const choice = selectEl.value;
    if (choice === 'upload') {
      const f = fileInputEl ? fileInputEl.files[0] : null;
      previewEl.value = f ? await f.text() : '';
      return;
    }
    const entry = WORDLISTS[choice];
    if (!entry) { previewEl.value = ''; return; }
    try {
      previewEl.value = (await loadWordlistFromPath(entry.path)).join('\n');
    } catch (e) {
      previewEl.value = '';
    }
  }

  // ========== Attack routines ==========

  async function attackBrute(limit){
    // Not implemented ‚Äî show informative alert.
    alert('Bruteforce √∫tok nen√≠ implementov√°n v t√©to verzi.');
  }

  async function attackWordList(limit){
    const algo = algoEl.value;
    const saltMode = saltModeEl.value;
    const saltPos = saltPosEl.value;
    const L = Math.min(limit, wordlist.length);
    let tested = 0;
    stopRequested = false;
    running = true;
    progressEl.max = db.length * Math.max(1, L);
    progressEl.value = 0;
    log(`Wordlist: zkou≈°√≠m a≈æ ${L} kandid√°t≈Ø pro ka≈æd√Ω z√°znam z ${db.length} u≈æivatel≈Ø ...`);
    for (let ci=0; ci<L; ci++){
      if (stopRequested) { log('Zru≈°eno u≈æivatelem'); break; }
      const cand = wordlist[ci];
      log(`Zkou≈°√≠m kandid√°ta #${ci+1}/${L}: "${cand}"`);
      const hashedCandidate = await digestText(algo, cand);
      for (let ui=0; ui<db.length; ui++){
        const row = db[ui];
        if (row.cracked) { progressEl.value++; continue; }
        tested++;
        if (hashedCandidate === row.hash){
          row.cracked = true; row.plain = cand;
          log(`‚úî nalezen: id=${row.id} email=${row.email} pwd=${cand}`);
          const tr = dbTableBody.querySelector(`tr[data-id="${row.id}"]`);
          if (tr){ tr.classList.add('ok'); tr.children[4].textContent = '‚úÖ'; tr.children[5].textContent = cand; }
        }
        progressEl.value++;
      }
      if (ci % 50 === 0) await new Promise(r => setTimeout(r,0));
    }
    running = false;
    log(`Wordlist finished. Tested ~${tested} candidate checks.`);
  }

  async function attackWordListSalted(limit){
    const algo = algoEl.value;
    const saltMode = saltModeEl.value;
    const saltPos = saltPosEl.value;
    const L = Math.min(limit, wordlist.length);
    let tested = 0;
    stopRequested = false;
    running = true;
    progressEl.max = db.length * Math.max(1, L);
    progressEl.value = 0;
    log(`Wordlist salted: zkou≈°√≠m a≈æ ${L} kandid√°t≈Ø z wordlistu pro ka≈æd√Ω z ${db.length} u≈æivatel≈Ø ...`);
    for (let ci=0; ci<L; ci++){
      if (stopRequested) { log('Zru≈°eno u≈æivatelem'); break; }
      const cand = wordlist[ci];
      log(`Zkou≈°√≠m kandid√°ta #${ci+1}/${L}: "${cand}"`);
      for (let ui=0; ui<db.length; ui++){
        const row = db[ui];
        if (row.cracked) { progressEl.value++; continue; }
        
        const saltedInput = (saltPos === 'prefix') ? (row.salt + cand) : (cand + row.salt);
        log(`Salted input for id=${row.id}: "${saltedInput}"`);
        const hashedCandidateSalted = await digestText(algo, saltedInput);
        
        tested++;
        if (hashedCandidateSalted === row.hash){
          row.cracked = true; row.plain = cand;
          log(`‚úî nalezen: id=${row.id} email=${row.email} pwd=${cand}`);
          const tr = dbTableBody.querySelector(`tr[data-id="${row.id}"]`);
          if (tr){ tr.classList.add('ok'); tr.children[4].textContent = '‚úÖ'; tr.children[5].textContent = cand; }
        }
        progressEl.value++;
      }
      if (ci % 50 === 0) await new Promise(r => setTimeout(r,0));
    }
    running = false;
    log(`Wordlist salted finished. Tested ~${tested} candidate checks.`);
  }

  async function attackRainbow(limit){
    if (saltModeEl.value !== 'none'){
      log('Pozor: rainbow tables obvykle nefunguj√≠, proto≈æe salt mƒõn√≠ hash. P≈ôepni salt na "none" nebo pou≈æij bruteforce.');
    }
    const algo = algoEl.value;
    const L = Math.min(limit, wordlist.length);
    const map = new Map();
    log(`Precomputing rainbow table for ${L} candidates (algo=${algo})...`);
    for (let i=0;i<L;i++){
      const pwd = wordlist[i];
      const h = await digestText(algo, pwd);
      map.set(h, pwd);
      if (i % 200 === 0) await new Promise(r => setTimeout(r,0));
    }
    log('Hotovo: rainbow mapa p≈ôipravena. Prob√≠h√° hled√°n√≠ v DB...');
    let found = 0;
    for (const row of db){
      if (stopRequested) { log('Zru≈°eno u≈æivatelem'); break; }
      if (row.cracked) continue;
      if (row.salt){
        log(`‚úñ p≈ôeskoƒçeno id=${row.id} (salted)`);
        continue;
      }
      const foundPwd = map.get(row.hash);
      if (foundPwd){
        row.cracked = true; row.plain = foundPwd; found++;
        const tr = dbTableBody.querySelector(`tr[data-id="${row.id}"]`);
        if (tr){ tr.classList.add('ok'); tr.children[4].textContent = '‚úÖ'; tr.children[5].textContent = foundPwd; }
        log(`‚úî rainbow hit id=${row.id} email=${row.email} pwd=${foundPwd}`);
      }
    }
    log(`Rainbow finished. Nalezeno: ${found}`);
  }

  // ========== Controls ==========
  // show salt options both for random per-user salt and regdate-derived salt
  saltModeEl.addEventListener('change', ()=> {
    saltOptionsEl.style.display = (saltModeEl.value === 'per-user' || saltModeEl.value === 'regdate') ? '' : 'none';
  });
 
  // show file-upload box only when user chooses 'upload'
  wordlistChoiceEl.addEventListener('change', ()=> {
    uploadBox.style.display = wordlistChoiceEl.value === 'upload' ? '' : 'none';
    updatePreviewFor(wordlistChoiceEl, previewEl, fileEl);
  });
  // when a file is selected, refresh preview if upload is active
  fileEl.addEventListener('change', ()=> {
    if (wordlistChoiceEl.value === 'upload') updatePreviewFor(wordlistChoiceEl, previewEl, fileEl);
  });
 
  // leak select listeners
  leakWordlistChoiceEl.addEventListener('change', async ()=> {
    leakUploadBox.style.display = leakWordlistChoiceEl.value === 'upload' ? '' : 'none';
    await loadLeakWordlist();
  });
  leakFileEl.addEventListener('change', async ()=> {
    if (leakWordlistChoiceEl.value === 'upload') await loadLeakWordlist();
  });

  btnGen.addEventListener('click', async ()=>{ 
    btnGen.disabled = true;
    // ensure leak wordlist is loaded before generating DB
    await loadLeakWordlist();
    await generateDB();
    try { renderDB(); } catch(e) { /* ignore */ }
    const firstRow = dbTableBody.querySelector('tr');
    if (firstRow) firstRow.scrollIntoView({behavior:'smooth', block:'start'});
    btnGen.disabled = false;
  });

  btnClear.addEventListener('click', ()=>{
    db = [];
    renderDB();
    clearLog();
    progressEl.value = 0;
  });

  btnStart.addEventListener('click', async ()=>{
    if (db.length === 0) { alert('Nejprve vygeneruj DB.'); return; }
    btnStart.disabled = true;
    btnStop.disabled = false;
    clearLog();
    await loadWordlist();
    const limit = Math.max(1, Math.min(1000000, parseInt(limitEl.value)||5000));
    const mode = attackModeEl.value;
    stopRequested = false;
    if (mode === 'rainbow') {
      await attackRainbow(limit);
    } else if (mode === 'wordlist') {
      await attackWordList(limit);
    } else if (mode === 'wordlist_salted') {
      await attackWordListSalted(limit);
    } else {
      await attackBrute(limit);
    }
    btnStart.disabled = false;
    btnStop.disabled = true;
    log('Konec √∫toku.');
  });

  btnStop.addEventListener('click', ()=>{
    stopRequested = true;
    btnStop.disabled = true;
    log('Stop requested...');
  });
  // ========== Initialization ==========
  (async ()=>{
    populateAllWordlistOptions();
    // preload both attacker and leak wordlists & previews
    await loadWordlist();
    await loadLeakWordlist();
  })();
</script>
</body>
</html>
