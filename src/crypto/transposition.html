<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8">
  <title>üîÄ Transpoziƒçn√≠ ≈°ifra ‚Äì n√°stroj</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../css/style.css">
  <style>
    .controls { display:grid; gap:10px }
    textarea { min-height:120px }
    .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center }
    .small-input { max-width:120px }
    .select { max-width:190px }
    .muted { color: var(--muted); font-size:.9rem }
    .result { white-space:pre-wrap; word-break:break-word }

    /* Tabulkov√° vizualizace */
    .grid-card h2 { margin-top:0 }
    .grid-info { margin-bottom:6px; font-size:.9rem; color:var(--muted); }
    .grid-table {
      display:inline-block;
      border-collapse:collapse;
      max-width:100%;
      overflow:auto;
    }
    .grid-table table {
      border-collapse:collapse;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:.9rem;
    }
    .grid-table th,
    .grid-table td {
      border:1px solid var(--border);
      padding:3px 6px;
      text-align:center;
      min-width:20px;
    }
    .grid-table th {
      background:var(--panel-2);
      position:sticky;
      top:0;
      z-index:1;
    }
    .grid-table .pad {
      opacity:.4;
    }
    .grid-table .cell-index {
      font-size:.7rem;
      color:var(--muted);
      display:block;
    }

    .grid-wrapper {
      max-width:100%;
      overflow:auto;
      padding:4px;
      border-radius:8px;
      background:var(--panel);
      border:1px solid var(--border);
    }

    .badge {
      display:inline-block;
      padding:2px 6px;
      border-radius:999px;
      background:var(--panel-2);
      font-size:.75rem;
      color:var(--muted);
      margin-left:4px;
    }
  </style>
</head>
<body>
<div class="app">
  <script type="module" src="../js/ui/site-header.js"></script>
  <site-header title="üîÄ Transpoziƒçn√≠ ≈°ifra" data-i18n="transposition.header"></site-header>

  <!-- Temporary language switcher (provisional, move to header later) -->
  <div style="margin:8px 0;">
    <label style="font-size:.9rem; margin-right:8px">Jazyk:</label>
    <select id="langSelect" class="form-control small-input">
      <option value="cs">ƒåesky</option>
      <option value="en">English</option>
    </select>
  </div>

  <div class="card">
    <p class="muted" data-i18n="transposition.description">
      Transpoziƒçn√≠ ≈°ifra mƒõn√≠ <strong>po≈ôad√≠ znak≈Ø</strong>, ale nemƒõn√≠ samotn√° p√≠smena.
      Zvol kl√≠ƒç, smƒõr z√°pisu a ƒçten√≠, p≈ô√≠padnƒõ dvojitou transpozici.
    </p>

    <div class="controls">
      <label data-i18n="transposition.input_label">
        Vstupn√≠ text:
        <textarea id="input" class="form-control" placeholder="Zadej text k za≈°ifrov√°n√≠ / de≈°ifrov√°n√≠..." data-i18n-placeholder="transposition.input_placeholder"></textarea>
      </label>

      <div class="row">
        <label data-i18n="transposition.key1_label">Kl√≠ƒç 1:
          <input id="key1" type="text" class="form-control small-input" placeholder="KL√çC1" data-i18n-placeholder="transposition.key1_placeholder" />
        </label>
        <label data-i18n="transposition.key2_label">Kl√≠ƒç 2:
          <input id="key2" type="text" class="form-control small-input" placeholder="KL√çC2 (pro dvojitou)" data-i18n-placeholder="transposition.key2_placeholder" />
        </label>
        <label data-i18n="transposition.pad_label">Dopl≈àovac√≠ znak:
          <input id="padChar" type="text" class="form-control small-input" value="X" maxlength="1" data-i18n-placeholder="transposition.pad_placeholder" />
        </label>
      </div>

      <div class="row">
        <label data-i18n="transposition.fill_label">Z√°pis do tabulky:
          <select id="fillMode" class="form-control select">
            <option value="row-lr" data-i18n="fill.row-lr">≈ò√°dky zleva doprava</option>
            <option value="row-rl" data-i18n="fill.row-rl">≈ò√°dky zprava doleva</option>
            <option value="col-tb" data-i18n="fill.col-tb">Sloupce shora dol≈Ø</option>
            <option value="col-bt" data-i18n="fill.col-bt">Sloupce zdola nahoru</option>
          </select>
        </label>
        <label data-i18n="transposition.read_label">ƒåten√≠ z tabulky:
          <select id="readMode" class="form-control select">
            <option value="col-tb" data-i18n="read.col-tb">Sloupce shora dol≈Ø</option>
            <option value="col-bt" data-i18n="read.col-bt">Sloupce zdola nahoru</option>
            <option value="row-lr" data-i18n="read.row-lr">≈ò√°dky zleva doprava</option>
            <option value="row-rl" data-i18n="read.row-rl">≈ò√°dky zprava doleva</option>
          </select>
        </label>
      </div>

      <div class="row">
        <label><input id="double" type="checkbox" /> <span data-i18n="transposition.double_label">dvojit√° transpozice (pou≈æij kl√≠ƒç 1 a 2)</span></label>
        <label><input id="normalize" type="checkbox" /> <span data-i18n="transposition.normalize_label">normalizovat (A‚ÄìZ, bez mezer/diakritiky)</span></label>
        <label><input id="lettersOnly" type="checkbox" /> <span data-i18n="transposition.lettersOnly_label">transponovat jen p√≠smena (mezery a interpunkce z≈Østanou)</span></label>
      </div>

      <div class="row" style="justify-content:center; margin-top:4px;">
        <button id="btnEnc" class="btn primary" data-i18n="transposition.encrypt_button">Za≈°ifrovat</button>
        <button id="btnDec" class="btn" data-i18n="transposition.decrypt_button">De≈°ifrovat</button>
      </div>

      <div>
        <label data-i18n="transposition.output_label">V√Ωsledek:
            <textarea id="output" class="form-control result" readonly placeholder="Zde se zobraz√≠ v√Ωsledek..." data-i18n-placeholder="transposition.output_placeholder"></textarea>
          </label>
      </div>
    </div>

    <p class="muted" style="margin-top:8px;" data-i18n="transposition.tip_text">
      Tip: zapni <code>dvojitou transpozici</code> a zmƒõ≈à smƒõr z√°pisu nebo ƒçten√≠.
      Sleduj, jak hodnƒõ se ≈°ifrotext li≈°√≠ od p≈Øvodn√≠ho textu.
    </p>
  </div>

  <!-- Vizualizace tabulky -->
  <div class="card grid-card">
    <div class="row" style="justify-content:space-between; align-items:center; margin-bottom:4px;">
      <h2 data-i18n="transposition.grid_title">Tabulka (vizualizace)</h2>
      <label class="muted">
        <input type="checkbox" id="toggleGrid" checked />
        <span data-i18n="transposition.grid_toggle">zobrazit tabulku</span>
      </label>
    </div>
    <div id="gridInfo" class="grid-info" data-i18n="transposition.grid_info_default">Tabulka se zobraz√≠ po zad√°n√≠ textu a kl√≠ƒçe.</div>
    <div id="gridPreview" class="grid-wrapper" style="display:none;">
      <div class="grid-table" id="gridTableContainer"></div>
    </div>
  </div>

  <script type="module" src="../js/site-doc.js"></script>
    <site-doc src="transposition_explain.md" title="üìò Vysvƒõtlen√≠" toggle></site-doc>
</div>

<script type="module">
  import { initI18n } from '../js/ui/i18n.js';
  import '../js/ui/site-header.js';
  import { transposeEncrypt, transposeDecrypt, normalizeAZ } from '../js/tools/crypto/transposition.js';

  // Ensure translations are loaded before we touch the DOM
  await initI18n();

  const $ = sel => document.querySelector(sel);

  // wire provisional language switcher
  const langSelectEl = document.getElementById('langSelect');
  if (langSelectEl) {
    // set initial value from document language set by initI18n
    try { langSelectEl.value = document.documentElement.lang || 'cs'; } catch(e) {}
    langSelectEl.addEventListener('change', (ev) => {
      const lang = ev.target.value;
      // dispatch event consumed by initI18n listener
      window.dispatchEvent(new CustomEvent('wt:setLang', { detail: { lang } }));
      // update select immediately
      langSelectEl.value = lang;
    });
  }

  const inputEl       = $('#input');
  const outputEl      = $('#output');
  const key1El        = $('#key1');
  const key2El        = $('#key2');
  const padCharEl     = $('#padChar');
  const fillModeEl    = $('#fillMode');
  const readModeEl    = $('#readMode');
  const doubleEl      = $('#double');
  const normalizeEl   = $('#normalize');
  const lettersOnlyEl = $('#lettersOnly');
  const btnEnc        = $('#btnEnc');
  const btnDec        = $('#btnDec');

  const toggleGridEl  = $('#toggleGrid');
  const gridInfoEl    = $('#gridInfo');
  const gridPreviewEl = $('#gridPreview');
  const gridTableContainer = $('#gridTableContainer');

  function getOptions() {
    const key1 = key1El.value || '';
    const key2 = key2El.value || '';
    const pad  = padCharEl.value || 'X';

    return {
      key1,
      key2,
      double: !!doubleEl.checked,
      fillMode: fillModeEl.value,
      readMode: readModeEl.value,
      padChar: (pad && pad.length ? pad[0] : 'X'),
      normalize: !!normalizeEl.checked,
      lettersOnly: !!lettersOnlyEl.checked
    };
  }

  // ==== Pomocn√© funkce pro vizualizaci (lightweight kopie z modulu) ====

  function columnOrderFromKey(key, cols) {
    const n = cols ?? Math.max(1, key?.length || 1);
    if (!key || !key.length) {
      return Array.from({ length: n }, (_, i) => i);
    }
    const pairs = Array.from({ length: n }, (_, i) => ({
      idx: i,
      ch: key[i] ?? String.fromCharCode(0x7f + i)
    }));
    pairs.sort((a, b) => {
      const ca = a.ch.toUpperCase();
      const cb = b.ch.toUpperCase();
      if (ca < cb) return -1;
      if (ca > cb) return 1;
      return a.idx - b.idx;
    });
    return pairs.map(p => p.idx);
  }

  function buildFillOrder(rows, cols, mode) {
    const out = [];
    if (mode === 'row-rl') {
      for (let r = 0; r < rows; r++) {
        for (let c = cols - 1; c >= 0; c--) out.push({ r, c });
      }
    } else if (mode === 'col-tb') {
      for (let c = 0; c < cols; c++) {
        for (let r = 0; r < rows; r++) out.push({ r, c });
      }
    } else if (mode === 'col-bt') {
      for (let c = 0; c < cols; c++) {
        for (let r = rows - 1; r >= 0; r--) out.push({ r, c });
      }
    } else {
      // row-lr
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) out.push({ r, c });
      }
    }
    return out;
  }

  // Jednoduch√Ω n√°hled: jak se text zap√≠≈°e do m≈ô√≠≈æky podle fillMode
  function buildGridForPreview(text, key, fillMode, padChar) {
    const cols = Math.max(1, key?.length || 1);
    const total = text.length;
    const rows = Math.ceil(total / cols);
    const cellCount = rows * cols;
    const padded = text.padEnd(cellCount, padChar);

    const fillOrder = buildFillOrder(rows, cols, fillMode);

    const grid = Array.from({ length: rows }, () =>
      Array.from({ length: cols }, () => padChar)
    );

    for (let i = 0; i < cellCount; i++) {
      const { r, c } = fillOrder[i];
      grid[r][c] = padded[i];
    }

    return { rows, cols, grid, paddedText: padded };
  }

  const letterRegex = /\p{L}/u;

  function textForGridPreview(input, opts) {
    if (opts.normalize) {
      return normalizeAZ(input);
    }
    if (opts.lettersOnly) {
      // do m≈ô√≠≈æky jen p√≠smena, ostatn√≠ z≈Østanou mimo transpozici
      const letters = [...input].filter(ch => letterRegex.test(ch));
      return letters.join('');
    }
    // z√°klad: vezmi text tak jak je (m≈Ø≈æe obsahovat i mezery)
    return input;
  }

  function renderGridPreview() {
    const opts = getOptions();
    const input = inputEl.value || '';

    if (!toggleGridEl.checked) {
      gridPreviewEl.style.display = 'none';
      gridInfoEl.textContent = 'Tabulka je skryta. Za≈°krtni ‚Äûzobrazit tabulku‚Äú pro n√°hled.';
      return;
    }

    const gridText = textForGridPreview(input, opts);
    if (!gridText.length) {
      gridPreviewEl.style.display = 'none';
      gridInfoEl.textContent = 'Zadej vstupn√≠ text a kl√≠ƒç, aby bylo co zobrazit v tabulce.';
      gridTableContainer.innerHTML = '';
      return;
    }

    const { rows, cols, grid, paddedText } =
      buildGridForPreview(gridText, opts.key1, opts.fillMode, opts.padChar);

    gridPreviewEl.style.display = '';
    const infoPieces = [];
    infoPieces.push(`D√©lka textu pro tabulku: ${gridText.length}`);
    infoPieces.push(`≈ò√°dky: ${rows}`);
    infoPieces.push(`Sloupce (d√©lka kl√≠ƒçe 1): ${cols}`);
    if (paddedText.length > gridText.length) {
      infoPieces.push(`doplnƒõno znakem "${opts.padChar}"`);
    }
    gridInfoEl.textContent = infoPieces.join(' ‚Ä¢ ');

    // Vykreslit tabulku
    const table = document.createElement('table');

    // Hlaviƒçka: index sloupc≈Ø + znak kl√≠ƒçe
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');

    const thEmpty = document.createElement('th');
    thEmpty.textContent = '#';
    hr.appendChild(thEmpty);

    const keyRow = document.createElement('tr');
    const thEmpty2 = document.createElement('th');
    thEmpty2.textContent = 'Kl√≠ƒç';
    keyRow.appendChild(thEmpty2);

    const keyArr = [...(opts.key1 || ''.padEnd(cols, ' '))];

    for (let c = 0; c < cols; c++) {
      const th = document.createElement('th');
      th.textContent = c + 1;
      hr.appendChild(th);

      const th2 = document.createElement('th');
      th2.textContent = keyArr[c] || ' ';
      keyRow.appendChild(th2);
    }

    thead.appendChild(hr);
    thead.appendChild(keyRow);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    let globalIndex = 0;

    for (let r = 0; r < rows; r++) {
      const tr = document.createElement('tr');
      const idxCell = document.createElement('td');
      idxCell.textContent = r + 1;
      idxCell.style.fontSize = '.8rem';
      idxCell.style.color = 'var(--muted)';
      tr.appendChild(idxCell);

      for (let c = 0; c < cols; c++) {
        const td = document.createElement('td');
        const ch = grid[r][c];
        const isPad = (globalIndex >= gridText.length);

        if (isPad) td.classList.add('pad');
        td.textContent = ch === ' ' ? '¬∑' : ch;
        tr.appendChild(td);
        globalIndex++;
      }
      tbody.appendChild(tr);
    }

    table.appendChild(tbody);

    gridTableContainer.innerHTML = '';
    gridTableContainer.appendChild(table);
  }

  // ==== Handlery ≈°ifrov√°n√≠/de≈°ifrov√°n√≠ ====

  btnEnc.addEventListener('click', () => {
    const text = inputEl.value || '';
    const opts = getOptions();

    if (opts.normalize) {
      opts.lettersOnly = false;
    }

    const res = transposeEncrypt(text, opts);
    outputEl.value = res;
    renderGridPreview();
  });

  btnDec.addEventListener('click', () => {
    const text = inputEl.value || '';
    const opts = getOptions();

    if (opts.normalize) {
      opts.lettersOnly = false;
    }

    const res = transposeDecrypt(text, opts);
    outputEl.value = res;
    renderGridPreview();
  });

  // Live update n√°hledu tabulky p≈ôi zmƒõnƒõ vstupu / nastaven√≠
  [inputEl, key1El, padCharEl, fillModeEl, normalizeEl, lettersOnlyEl].forEach(el => {
    el.addEventListener('input', renderGridPreview);
  });
  [toggleGridEl].forEach(el => {
    el.addEventListener('change', renderGridPreview);
  });

  // Inicializace
  renderGridPreview();
</script>
</body>
</html>
